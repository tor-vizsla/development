<!DOCTYPE HTML>
<HTML>
 <HEAD>
  <TITLE>JSC3D - H2O</TITLE>
     <style type="text/css">
    div {
    cursor:all-scroll;
    }
     </style>
 </HEAD>
 <BODY onload="init()">
	<div>
		<canvas id="cv" style="border: 0px solid;" width="800" height="520" >Your browser does not support the canvas feature.</canvas>
	</div>
     <script type="text/javascript" src="js/jsc3d.js"></script>
     
	<!--script type="text/javascript" src="js/jsc3d.touch.js"></script-->
     <script type="text/javascript">
         /**
 * @preserve Copyright (c) 2011~2013 Humu <humu2009@gmail.com>
 * This file is part of jsc3d project, which is freely distributable under the 
 * terms of the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


         /**
             @namespace JSC3D
          */
         var JSC3D = JSC3D || {};

         /**
          * The following part of the file is a modified copy of hammer.js, which is 
          * released by Jorik Tangelder <j.tangelder@gmail.com> under the terms of the
          * MIT license.
          */

         /*
          * ! Hammer.JS - v1.0.5 - 2013-04-07
          * http://eightmedia.github.com/hammer.js
          *
          * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
          * Licensed under the MIT license
          */

         (function (window, undefined) {
             'use strict';

             /**
              * Hammer
              * use this to create instances
              * @param   {HTMLElement}   element
              * @param   {Object}        options
              * @returns {Hammer.Instance}
              * @constructor
              */
             var Hammer = function (element, options) {
                 return new Hammer.Instance(element, options || {});
             };

             // default settings
             Hammer.defaults = {
                 // add styles and attributes to the element to prevent the browser from doing
                 // its native behavior. this doesnt prevent the scrolling, but cancels
                 // the contextmenu, tap highlighting etc
                 // set to false to disable this
                 stop_browser_behavior: {
                     // this also triggers onselectstart=false for IE
                     userSelect: 'none',
                     // this makes the element blocking in IE10 >, you could experiment with the value
                     // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241
                     touchAction: 'none',
                     touchCallout: 'none',
                     contentZooming: 'none',
                     userDrag: 'none',
                     tapHighlightColor: 'rgba(0,0,0,0)'
                 }

                 // more settings are defined per gesture at gestures.js
             };

             // detect touchevents
             Hammer.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled;
             Hammer.HAS_TOUCHEVENTS = ('ontouchstart' in window);

             // dont use mouseevents on mobile devices
             Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
             Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && navigator.userAgent.match(Hammer.MOBILE_REGEX);

             // eventtypes per touchevent (start, move, end)
             // are filled by Hammer.event.determineEventTypes on setup
             Hammer.EVENT_TYPES = {};

             // direction defines
             Hammer.DIRECTION_DOWN = 'down';
             Hammer.DIRECTION_LEFT = 'left';
             Hammer.DIRECTION_UP = 'up';
             Hammer.DIRECTION_RIGHT = 'right';

             // pointer type
             Hammer.POINTER_MOUSE = 'mouse';
             Hammer.POINTER_TOUCH = 'touch';
             Hammer.POINTER_PEN = 'pen';

             // touch event defines
             Hammer.EVENT_START = 'start';
             Hammer.EVENT_MOVE = 'move';
             Hammer.EVENT_END = 'end';

             // hammer document where the base events are added at
             Hammer.DOCUMENT = document;

             // plugins namespace
             Hammer.plugins = {};

             // if the window events are set...
             Hammer.READY = false;

             /**
              * setup events to detect gestures on the document
              */
             function setup() {
                 if (Hammer.READY) {
                     return;
                 }

                 // find what eventtypes we add listeners to
                 Hammer.event.determineEventTypes();

                 // Register all gestures inside Hammer.gestures
                 for (var name in Hammer.gestures) {
                     if (Hammer.gestures.hasOwnProperty(name)) {
                         Hammer.detection.register(Hammer.gestures[name]);
                     }
                 }

                 // Add touch events on the document
                 Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);
                 Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);

                 // Hammer is ready...!
                 Hammer.READY = true;
             }

             /**
              * create new hammer instance
              * all methods should return the instance itself, so it is chainable.
              * @param   {HTMLElement}       element
              * @param   {Object}            options={}
              * @returns {Hammer.Instance}
              * @constructor
              */
             Hammer.Instance = function (element, options) {
                 var self = this;

                 // setup HammerJS window events and register all gestures
                 // this also sets up the default options
                 setup();

                 this.element = element;

                 // start/stop detection option
                 this.enabled = true;

                 // merge options
                 this.options = Hammer.utils.extend(
                     Hammer.utils.extend({}, Hammer.defaults),
                     options || {});

                 // add some css to the element to prevent the browser from doing its native behavoir
                 if (this.options.stop_browser_behavior) {
                     Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);
                 }

                 // start detection on touchstart
                 Hammer.event.onTouch(element, Hammer.EVENT_START, function (ev) {
                     if (self.enabled) {
                         Hammer.detection.startDetect(self, ev);
                     }
                 });

                 // return instance
                 return this;
             };


             Hammer.Instance.prototype = {
                 /**
                  * bind events to the instance
                  * @param   {String}      gesture
                  * @param   {Function}    handler
                  * @returns {Hammer.Instance}
                  */
                 on: function onEvent(gesture, handler) {
                     var gestures = gesture.split(' ');
                     for (var t = 0; t < gestures.length; t++) {
                         this.element.addEventListener(gestures[t], handler, false);
                     }
                     return this;
                 },


                 /**
                  * unbind events to the instance
                  * @param   {String}      gesture
                  * @param   {Function}    handler
                  * @returns {Hammer.Instance}
                  */
                 off: function offEvent(gesture, handler) {
                     var gestures = gesture.split(' ');
                     for (var t = 0; t < gestures.length; t++) {
                         this.element.removeEventListener(gestures[t], handler, false);
                     }
                     return this;
                 },


                 /**
                  * trigger gesture event
                  * @param   {String}      gesture
                  * @param   {Object}      eventData
                  * @returns {Hammer.Instance}
                  */
                 trigger: function triggerEvent(gesture, eventData) {
                     // create DOM event
                     var event = Hammer.DOCUMENT.createEvent('Event');
                     event.initEvent(gesture, true, true);
                     event.gesture = eventData;

                     // trigger on the target if it is in the instance element,
                     // this is for event delegation tricks
                     var element = this.element;
                     if (Hammer.utils.hasParent(eventData.target, element)) {
                         element = eventData.target;
                     }

                     element.dispatchEvent(event);
                     return this;
                 },


                 /**
                  * enable of disable hammer.js detection
                  * @param   {Boolean}   state
                  * @returns {Hammer.Instance}
                  */
                 enable: function enable(state) {
                     this.enabled = state;
                     return this;
                 }
             };

             /**
              * this holds the last move event,
              * used to fix empty touchend issue
              * see the onTouch event for an explanation
              * @type {Object}
              */
             var last_move_event = null;


             /**
              * when the mouse is hold down, this is true
              * @type {Boolean}
              */
             var enable_detect = false;


             /**
              * when touch events have been fired, this is true
              * @type {Boolean}
              */
             var touch_triggered = false;


             Hammer.event = {
                 /**
                  * simple addEventListener
                  * @param   {HTMLElement}   element
                  * @param   {String}        type
                  * @param   {Function}      handler
                  */
                 bindDom: function (element, type, handler) {
                     var types = type.split(' ');
                     for (var t = 0; t < types.length; t++) {
                         element.addEventListener(types[t], handler, false);
                     }
                 },


                 /**
                  * touch events with mouse fallback
                  * @param   {HTMLElement}   element
                  * @param   {String}        eventType        like Hammer.EVENT_MOVE
                  * @param   {Function}      handler
                  */
                 onTouch: function onTouch(element, eventType, handler) {
                     var self = this;

                     this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {
                         var sourceEventType = ev.type.toLowerCase();

                         // onmouseup, but when touchend has been fired we do nothing.
                         // this is for touchdevices which also fire a mouseup on touchend
                         if (sourceEventType.match(/mouse/) && touch_triggered) {
                             return;
                         }

                             // mousebutton must be down or a touch event
                         else if (sourceEventType.match(/touch/) ||   // touch events are always on screen
                             sourceEventType.match(/pointerdown/) || // pointerevents touch
                             (sourceEventType.match(/mouse/) && ev.which === 1)   // mouse is pressed
                         ) {
                             enable_detect = true;
                         }

                         // we are in a touch event, set the touch triggered bool to true,
                         // this for the conflicts that may occur on ios and android
                         if (sourceEventType.match(/touch|pointer/)) {
                             touch_triggered = true;
                         }

                         // count the total touches on the screen
                         var count_touches = 0;

                         // when touch has been triggered in this detection session
                         // and we are now handling a mouse event, we stop that to prevent conflicts
                         if (enable_detect) {
                             // update pointerevent
                             if (Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {
                                 count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                             }
                                 // touch
                             else if (sourceEventType.match(/touch/)) {
                                 count_touches = ev.touches.length;
                             }
                                 // mouse
                             else if (!touch_triggered) {
                                 count_touches = sourceEventType.match(/up/) ? 0 : 1;
                             }

                             // if we are in a end event, but when we remove one touch and
                             // we still have enough, set eventType to move
                             if (count_touches > 0 && eventType == Hammer.EVENT_END) {
                                 eventType = Hammer.EVENT_MOVE;
                             }
                                 // no touches, force the end event
                             else if (!count_touches) {
                                 eventType = Hammer.EVENT_END;
                             }

                             // because touchend has no touches, and we often want to use these in our gestures,
                             // we send the last move event as our eventData in touchend
                             if (!count_touches && last_move_event !== null) {
                                 ev = last_move_event;
                             }
                                 // store the last move event
                             else {
                                 last_move_event = ev;
                             }

                             // trigger the handler
                             handler.call(Hammer.detection, self.collectEventData(element, eventType, ev));

                             // remove pointerevent from list
                             if (Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {
                                 count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);
                             }
                         }

                         //debug(sourceEventType +" "+ eventType);

                         // on the end we reset everything
                         if (!count_touches) {
                             last_move_event = null;
                             enable_detect = false;
                             touch_triggered = false;
                             Hammer.PointerEvent.reset();
                         }
                     });
                 },


                 /**
                  * we have different events for each device/browser
                  * determine what we need and set them in the Hammer.EVENT_TYPES constant
                  */
                 determineEventTypes: function determineEventTypes() {
                     // determine the eventtype we want to set
                     var types;

                     // pointerEvents magic
                     if (Hammer.HAS_POINTEREVENTS) {
                         types = Hammer.PointerEvent.getEvents();
                     }
                         // on Android, iOS, blackberry, windows mobile we dont want any mouseevents
                     else if (Hammer.NO_MOUSEEVENTS) {
                         types = [
                             'touchstart',
                             'touchmove',
                             'touchend touchcancel'];
                     }
                         // for non pointer events browsers and mixed browsers,
                         // like chrome on windows8 touch laptop
                     else {
                         types = [
                             'touchstart mousedown',
                             'touchmove mousemove',
                             'touchend touchcancel mouseup'];
                     }

                     Hammer.EVENT_TYPES[Hammer.EVENT_START] = types[0];
                     Hammer.EVENT_TYPES[Hammer.EVENT_MOVE] = types[1];
                     Hammer.EVENT_TYPES[Hammer.EVENT_END] = types[2];
                 },


                 /**
                  * create touchlist depending on the event
                  * @param   {Object}    ev
                  * @param   {String}    eventType   used by the fakemultitouch plugin
                  */
                 getTouchList: function getTouchList(ev/*, eventType*/) {
                     // get the fake pointerEvent touchlist
                     if (Hammer.HAS_POINTEREVENTS) {
                         return Hammer.PointerEvent.getTouchList();
                     }
                         // get the touchlist
                     else if (ev.touches) {
                         return ev.touches;
                     }
                         // make fake touchlist from mouse position
                     else {
                         return [{
                             identifier: 1,
                             pageX: ev.pageX,
                             pageY: ev.pageY,
                             target: ev.target
                         }];
                     }
                 },


                 /**
                  * collect event data for Hammer js
                  * @param   {HTMLElement}   element
                  * @param   {String}        eventType        like Hammer.EVENT_MOVE
                  * @param   {Object}        eventData
                  */
                 collectEventData: function collectEventData(element, eventType, ev) {
                     var touches = this.getTouchList(ev, eventType);

                     // find out pointerType
                     var pointerType = Hammer.POINTER_TOUCH;
                     if (ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {
                         pointerType = Hammer.POINTER_MOUSE;
                     }

                     return {
                         center: Hammer.utils.getCenter(touches),
                         timeStamp: new Date().getTime(),
                         target: ev.target,
                         touches: touches,
                         eventType: eventType,
                         pointerType: pointerType,
                         srcEvent: ev,

                         /**
                          * prevent the browser default actions
                          * mostly used to disable scrolling of the browser
                          */
                         preventDefault: function () {
                             if (this.srcEvent.preventManipulation) {
                                 this.srcEvent.preventManipulation();
                             }

                             if (this.srcEvent.preventDefault) {
                                 this.srcEvent.preventDefault();
                             }
                         },

                         /**
                          * stop bubbling the event up to its parents
                          */
                         stopPropagation: function () {
                             this.srcEvent.stopPropagation();
                         },

                         /**
                          * immediately stop gesture detection
                          * might be useful after a swipe was detected
                          * @return {*}
                          */
                         stopDetect: function () {
                             return Hammer.detection.stopDetect();
                         }
                     };
                 }
             };

             Hammer.PointerEvent = {
                 /**
                  * holds all pointers
                  * @type {Object}
                  */
                 pointers: {},

                 /**
                  * get a list of pointers
                  * @returns {Array}     touchlist
                  */
                 getTouchList: function () {
                     var self = this;
                     var touchlist = [];

                     // we can use forEach since pointerEvents only is in IE10
                     Object.keys(self.pointers).sort().forEach(function (id) {
                         touchlist.push(self.pointers[id]);
                     });
                     return touchlist;
                 },

                 /**
                  * update the position of a pointer
                  * @param   {String}   type             Hammer.EVENT_END
                  * @param   {Object}   pointerEvent
                  */
                 updatePointer: function (type, pointerEvent) {
                     if (type == Hammer.EVENT_END) {
                         this.pointers = {};
                     }
                     else {
                         pointerEvent.identifier = pointerEvent.pointerId;
                         this.pointers[pointerEvent.pointerId] = pointerEvent;
                     }

                     return Object.keys(this.pointers).length;
                 },

                 /**
                  * check if ev matches pointertype
                  * @param   {String}        pointerType     Hammer.POINTER_MOUSE
                  * @param   {PointerEvent}  ev
                  */
                 matchType: function (pointerType, ev) {
                     if (!ev.pointerType) {
                         return false;
                     }

                     var types = {};
                     types[Hammer.POINTER_MOUSE] = (ev.pointerType == ev.MSPOINTER_TYPE_MOUSE || ev.pointerType == Hammer.POINTER_MOUSE);
                     types[Hammer.POINTER_TOUCH] = (ev.pointerType == ev.MSPOINTER_TYPE_TOUCH || ev.pointerType == Hammer.POINTER_TOUCH);
                     types[Hammer.POINTER_PEN] = (ev.pointerType == ev.MSPOINTER_TYPE_PEN || ev.pointerType == Hammer.POINTER_PEN);
                     return types[pointerType];
                 },


                 /**
                  * get events
                  */
                 getEvents: function () {
                     return [
                         'pointerdown MSPointerDown',
                         'pointermove MSPointerMove',
                         'pointerup pointercancel MSPointerUp MSPointerCancel'
                     ];
                 },

                 /**
                  * reset the list
                  */
                 reset: function () {
                     this.pointers = {};
                 }
             };


             Hammer.utils = {
                 /**
                  * extend method,
                  * also used for cloning when dest is an empty object
                  * @param   {Object}    dest
                  * @param   {Object}    src
                  * @parm	{Boolean}	merge		do a merge
                  * @returns {Object}    dest
                  */
                 extend: function extend(dest, src, merge) {
                     for (var key in src) {
                         if (dest[key] !== undefined && merge) {
                             continue;
                         }
                         dest[key] = src[key];
                     }
                     return dest;
                 },


                 /**
                  * find if a node is in the given parent
                  * used for event delegation tricks
                  * @param   {HTMLElement}   node
                  * @param   {HTMLElement}   parent
                  * @returns {boolean}       has_parent
                  */
                 hasParent: function (node, parent) {
                     while (node) {
                         if (node == parent) {
                             return true;
                         }
                         node = node.parentNode;
                     }
                     return false;
                 },


                 /**
                  * get the center of all the touches
                  * @param   {Array}     touches
                  * @returns {Object}    center
                  */
                 getCenter: function getCenter(touches) {
                     var valuesX = [], valuesY = [];

                     for (var t = 0, len = touches.length; t < len; t++) {
                         valuesX.push(touches[t].pageX);
                         valuesY.push(touches[t].pageY);
                     }

                     return {
                         pageX: ((Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2),
                         pageY: ((Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2)
                     };
                 },


                 /**
                  * calculate the velocity between two points
                  * @param   {Number}    delta_time
                  * @param   {Number}    delta_x
                  * @param   {Number}    delta_y
                  * @returns {Object}    velocity
                  */
                 getVelocity: function getVelocity(delta_time, delta_x, delta_y) {
                     return {
                         x: Math.abs(delta_x / delta_time) || 0,
                         y: Math.abs(delta_y / delta_time) || 0
                     };
                 },


                 /**
                  * calculate the angle between two coordinates
                  * @param   {Touch}     touch1
                  * @param   {Touch}     touch2
                  * @returns {Number}    angle
                  */
                 getAngle: function getAngle(touch1, touch2) {
                     var y = touch2.pageY - touch1.pageY,
                         x = touch2.pageX - touch1.pageX;
                     return Math.atan2(y, x) * 180 / Math.PI;
                 },


                 /**
                  * angle to direction define
                  * @param   {Touch}     touch1
                  * @param   {Touch}     touch2
                  * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT
                  */
                 getDirection: function getDirection(touch1, touch2) {
                     var x = Math.abs(touch1.pageX - touch2.pageX),
                         y = Math.abs(touch1.pageY - touch2.pageY);

                     if (x >= y) {
                         return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                     }
                     else {
                         return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                     }
                 },


                 /**
                  * calculate the distance between two touches
                  * @param   {Touch}     touch1
                  * @param   {Touch}     touch2
                  * @returns {Number}    distance
                  */
                 getDistance: function getDistance(touch1, touch2) {
                     var x = touch2.pageX - touch1.pageX,
                         y = touch2.pageY - touch1.pageY;
                     return Math.sqrt((x * x) + (y * y));
                 },


                 /**
                  * calculate the scale factor between two touchLists (fingers)
                  * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
                  * @param   {Array}     start
                  * @param   {Array}     end
                  * @returns {Number}    scale
                  */
                 getScale: function getScale(start, end) {
                     // need two fingers...
                     if (start.length >= 2 && end.length >= 2) {
                         return this.getDistance(end[0], end[1]) /
                             this.getDistance(start[0], start[1]);
                     }
                     return 1;
                 },


                 /**
                  * calculate the rotation degrees between two touchLists (fingers)
                  * @param   {Array}     start
                  * @param   {Array}     end
                  * @returns {Number}    rotation
                  */
                 getRotation: function getRotation(start, end) {
                     // need two fingers
                     if (start.length >= 2 && end.length >= 2) {
                         return this.getAngle(end[1], end[0]) -
                             this.getAngle(start[1], start[0]);
                     }
                     return 0;
                 },


                 /**
                  * boolean if the direction is vertical
                  * @param    {String}    direction
                  * @returns  {Boolean}   is_vertical
                  */
                 isVertical: function isVertical(direction) {
                     return (direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN);
                 },


                 /**
                  * stop browser default behavior with css props
                  * @param   {HtmlElement}   element
                  * @param   {Object}        css_props
                  */
                 stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {
                     var prop,
                         vendors = ['webkit', 'khtml', 'moz', 'ms', 'o', ''];

                     if (!css_props || !element.style) {
                         return;
                     }

                     // with css properties for modern browsers
                     for (var i = 0; i < vendors.length; i++) {
                         for (var p in css_props) {
                             if (css_props.hasOwnProperty(p)) {
                                 prop = p;

                                 // vender prefix at the property
                                 if (vendors[i]) {
                                     prop = vendors[i] + prop.substring(0, 1).toUpperCase() + prop.substring(1);
                                 }

                                 // set the style
                                 element.style[prop] = css_props[p];
                             }
                         }
                     }

                     // also the disable onselectstart
                     if (css_props.userSelect == 'none') {
                         element.onselectstart = function () {
                             return false;
                         };
                     }
                 }
             };

             Hammer.detection = {
                 // contains all registred Hammer.gestures in the correct order
                 gestures: [],

                 // data of the current Hammer.gesture detection session
                 current: null,

                 // the previous Hammer.gesture session data
                 // is a full clone of the previous gesture.current object
                 previous: null,

                 // when this becomes true, no gestures are fired
                 stopped: false,


                 /**
                  * start Hammer.gesture detection
                  * @param   {Hammer.Instance}   inst
                  * @param   {Object}            eventData
                  */
                 startDetect: function startDetect(inst, eventData) {
                     // already busy with a Hammer.gesture detection on an element
                     if (this.current) {
                         return;
                     }

                     this.stopped = false;

                     this.current = {
                         inst: inst, // reference to HammerInstance we're working for
                         startEvent: Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc
                         lastEvent: false, // last eventData
                         name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc
                     };

                     this.detect(eventData);
                 },


                 /**
                  * Hammer.gesture detection
                  * @param   {Object}    eventData
                  */
                 detect: function detect(eventData) {
                     if (!this.current || this.stopped) {
                         return;
                     }

                     // extend event data with calculations about scale, distance etc
                     eventData = this.extendEventData(eventData);

                     // instance options
                     var inst_options = this.current.inst.options;

                     // call Hammer.gesture handlers
                     for (var g = 0, len = this.gestures.length; g < len; g++) {
                         var gesture = this.gestures[g];

                         // only when the instance options have enabled this gesture
                         if (!this.stopped && inst_options[gesture.name] !== false) {
                             // if a handler returns false, we stop with the detection
                             if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {
                                 this.stopDetect();
                                 break;
                             }
                         }
                     }

                     // store as previous event event
                     if (this.current) {
                         this.current.lastEvent = eventData;
                     }

                     // endevent, but not the last touch, so dont stop
                     if (eventData.eventType == Hammer.EVENT_END && !eventData.touches.length - 1) {
                         this.stopDetect();
                     }

                     return eventData;
                 },


                 /**
                  * clear the Hammer.gesture vars
                  * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected
                  * to stop other Hammer.gestures from being fired
                  */
                 stopDetect: function stopDetect() {
                     // clone current data to the store as the previous gesture
                     // used for the double tap gesture, since this is an other gesture detect session
                     this.previous = Hammer.utils.extend({}, this.current);

                     // reset the current
                     this.current = null;

                     // stopped!
                     this.stopped = true;
                 },


                 /**
                  * extend eventData for Hammer.gestures
                  * @param   {Object}   ev
                  * @returns {Object}   ev
                  */
                 extendEventData: function extendEventData(ev) {
                     var startEv = this.current.startEvent;

                     // if the touches change, set the new touches over the startEvent touches
                     // this because touchevents don't have all the touches on touchstart, or the
                     // user must place his fingers at the EXACT same time on the screen, which is not realistic
                     // but, sometimes it happens that both fingers are touching at the EXACT same time
                     if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {
                         // extend 1 level deep to get the touchlist with the touch objects
                         startEv.touches = [];
                         for (var i = 0, len = ev.touches.length; i < len; i++) {
                             startEv.touches.push(Hammer.utils.extend({}, ev.touches[i]));
                         }
                     }

                     var delta_time = ev.timeStamp - startEv.timeStamp,
                         delta_x = ev.center.pageX - startEv.center.pageX,
                         delta_y = ev.center.pageY - startEv.center.pageY,
                         velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y);

                     Hammer.utils.extend(ev, {
                         deltaTime: delta_time,

                         deltaX: delta_x,
                         deltaY: delta_y,

                         velocityX: velocity.x,
                         velocityY: velocity.y,

                         distance: Hammer.utils.getDistance(startEv.center, ev.center),
                         angle: Hammer.utils.getAngle(startEv.center, ev.center),
                         direction: Hammer.utils.getDirection(startEv.center, ev.center),

                         scale: Hammer.utils.getScale(startEv.touches, ev.touches),
                         rotation: Hammer.utils.getRotation(startEv.touches, ev.touches),

                         startEvent: startEv
                     });

                     return ev;
                 },


                 /**
                  * register new gesture
                  * @param   {Object}    gesture object, see gestures.js for documentation
                  * @returns {Array}     gestures
                  */
                 register: function register(gesture) {
                     // add an enable gesture options if there is no given
                     var options = gesture.defaults || {};
                     if (options[gesture.name] === undefined) {
                         options[gesture.name] = true;
                     }

                     // extend Hammer default options with the Hammer.gesture options
                     Hammer.utils.extend(Hammer.defaults, options, true);

                     // set its index
                     gesture.index = gesture.index || 1000;

                     // add Hammer.gesture to the list
                     this.gestures.push(gesture);

                     // sort the list by index
                     this.gestures.sort(function (a, b) {
                         if (a.index < b.index) {
                             return -1;
                         }
                         if (a.index > b.index) {
                             return 1;
                         }
                         return 0;
                     });

                     return this.gestures;
                 }
             };


             Hammer.gestures = Hammer.gestures || {};

             /**
              * Custom gestures
              * ==============================
              *
              * Gesture object
              * --------------------
              * The object structure of a gesture:
              *
              * { name: 'mygesture',
              *   index: 1337,
              *   defaults: {
              *     mygesture_option: true
              *   }
              *   handler: function(type, ev, inst) {
              *     // trigger gesture event
              *     inst.trigger(this.name, ev);
              *   }
              * }
             
              * @param   {String}    name
              * this should be the name of the gesture, lowercase
              * it is also being used to disable/enable the gesture per instance config.
              *
              * @param   {Number}    [index=1000]
              * the index of the gesture, where it is going to be in the stack of gestures detection
              * like when you build an gesture that depends on the drag gesture, it is a good
              * idea to place it after the index of the drag gesture.
              *
              * @param   {Object}    [defaults={}]
              * the default settings of the gesture. these are added to the instance settings,
              * and can be overruled per instance. you can also add the name of the gesture,
              * but this is also added by default (and set to true).
              *
              * @param   {Function}  handler
              * this handles the gesture detection of your custom gesture and receives the
              * following arguments:
              *
              *      @param  {Object}    eventData
              *      event data containing the following properties:
              *          timeStamp   {Number}        time the event occurred
              *          target      {HTMLElement}   target element
              *          touches     {Array}         touches (fingers, pointers, mouse) on the screen
              *          pointerType {String}        kind of pointer that was used. matches Hammer.POINTER_MOUSE|TOUCH
              *          center      {Object}        center position of the touches. contains pageX and pageY
              *          deltaTime   {Number}        the total time of the touches in the screen
              *          deltaX      {Number}        the delta on x axis we haved moved
              *          deltaY      {Number}        the delta on y axis we haved moved
              *          velocityX   {Number}        the velocity on the x
              *          velocityY   {Number}        the velocity on y
              *          angle       {Number}        the angle we are moving
              *          direction   {String}        the direction we are moving. matches Hammer.DIRECTION_UP|DOWN|LEFT|RIGHT
              *          distance    {Number}        the distance we haved moved
              *          scale       {Number}        scaling of the touches, needs 2 touches
              *          rotation    {Number}        rotation of the touches, needs 2 touches *
              *          eventType   {String}        matches Hammer.EVENT_START|MOVE|END
              *          srcEvent    {Object}        the source event, like TouchStart or MouseDown *
              *          startEvent  {Object}        contains the same properties as above,
              *                                      but from the first touch. this is used to calculate
              *                                      distances, deltaTime, scaling etc
              *
              *      @param  {Hammer.Instance}    inst
              *      the instance we are doing the detection for. you can get the options from
              *      the inst.options object and trigger the gesture event by calling inst.trigger
              *
              *
              * Handle gestures
              * --------------------
              * inside the handler you can get/set Hammer.detection.current. This is the current
              * detection session. It has the following properties
              *      @param  {String}    name
              *      contains the name of the gesture we have detected. it has not a real function,
              *      only to check in other gestures if something is detected.
              *      like in the drag gesture we set it to 'drag' and in the swipe gesture we can
              *      check if the current gesture is 'drag' by accessing Hammer.detection.current.name
              *
              *      @readonly
              *      @param  {Hammer.Instance}    inst
              *      the instance we do the detection for
              *
              *      @readonly
              *      @param  {Object}    startEvent
              *      contains the properties of the first gesture detection in this session.
              *      Used for calculations about timing, distance, etc.
              *
              *      @readonly
              *      @param  {Object}    lastEvent
              *      contains all the properties of the last gesture detect in this session.
              *
              * after the gesture detection session has been completed (user has released the screen)
              * the Hammer.detection.current object is copied into Hammer.detection.previous,
              * this is usefull for gestures like doubletap, where you need to know if the
              * previous gesture was a tap
              *
              * options that have been set by the instance can be received by calling inst.options
              *
              * You can trigger a gesture event by calling inst.trigger("mygesture", event).
              * The first param is the name of your gesture, the second the event argument
              *
              *
              * Register gestures
              * --------------------
              * When an gesture is added to the Hammer.gestures object, it is auto registered
              * at the setup of the first Hammer instance. You can also call Hammer.detection.register
              * manually and pass your gesture object as a param
              *
              */

             /**
              * Hold
              * Touch stays at the same place for x time
              * @events  hold
              */
             Hammer.gestures.Hold = {
                 name: 'hold',
                 index: 10,
                 defaults: {
                     hold_timeout: 500,
                     hold_threshold: 1
                 },
                 timer: null,
                 handler: function holdGesture(ev, inst) {
                     switch (ev.eventType) {
                         case Hammer.EVENT_START:
                             // clear any running timers
                             clearTimeout(this.timer);

                             // set the gesture so we can check in the timeout if it still is
                             Hammer.detection.current.name = this.name;

                             // set timer and if after the timeout it still is hold,
                             // we trigger the hold event
                             this.timer = setTimeout(function () {
                                 if (Hammer.detection.current.name == 'hold') {
                                     inst.trigger('hold', ev);
                                 }
                             }, inst.options.hold_timeout);
                             break;

                             // when you move or end we clear the timer
                         case Hammer.EVENT_MOVE:
                             if (ev.distance > inst.options.hold_threshold) {
                                 clearTimeout(this.timer);
                             }
                             break;

                         case Hammer.EVENT_END:
                             clearTimeout(this.timer);
                             break;
                     }
                 }
             };


             /**
              * Tap/DoubleTap
              * Quick touch at a place or double at the same place
              * @events  tap, doubletap
              */
             Hammer.gestures.Tap = {
                 name: 'tap',
                 index: 100,
                 defaults: {
                     tap_max_touchtime: 250,
                     tap_max_distance: 10,
                     tap_always: true,
                     doubletap_distance: 20,
                     doubletap_interval: 300
                 },
                 handler: function tapGesture(ev, inst) {
                     if (ev.eventType == Hammer.EVENT_END) {
                         // previous gesture, for the double tap since these are two different gesture detections
                         var prev = Hammer.detection.previous,
                             did_doubletap = false;

                         // when the touchtime is higher then the max touch time
                         // or when the moving distance is too much
                         if (ev.deltaTime > inst.options.tap_max_touchtime ||
                             ev.distance > inst.options.tap_max_distance) {
                             return;
                         }

                         // check if double tap
                         if (prev && prev.name == 'tap' &&
                             (ev.timeStamp - prev.lastEvent.timeStamp) < inst.options.doubletap_interval &&
                             ev.distance < inst.options.doubletap_distance) {
                             inst.trigger('doubletap', ev);
                             did_doubletap = true;
                         }

                         // do a single tap
                         if (!did_doubletap || inst.options.tap_always) {
                             Hammer.detection.current.name = 'tap';
                             inst.trigger(Hammer.detection.current.name, ev);
                         }
                     }
                 }
             };


             /**
              * Swipe
              * triggers swipe events when the end velocity is above the threshold
              * @events  swipe, swipeleft, swiperight, swipeup, swipedown
              */
             Hammer.gestures.Swipe = {
                 name: 'swipe',
                 index: 40,
                 defaults: {
                     // set 0 for unlimited, but this can conflict with transform
                     swipe_max_touches: 1,
                     swipe_velocity: 0.7
                 },
                 handler: function swipeGesture(ev, inst) {
                     if (ev.eventType == Hammer.EVENT_END) {
                         // max touches
                         if (inst.options.swipe_max_touches > 0 &&
                             ev.touches.length > inst.options.swipe_max_touches) {
                             return;
                         }

                         // when the distance we moved is too small we skip this gesture
                         // or we can be already in dragging
                         if (ev.velocityX > inst.options.swipe_velocity ||
                             ev.velocityY > inst.options.swipe_velocity) {
                             // trigger swipe events
                             inst.trigger(this.name, ev);
                             inst.trigger(this.name + ev.direction, ev);
                         }
                     }
                 }
             };


             /**
              * Drag
              * Move with x fingers (default 1) around on the page. Blocking the scrolling when
              * moving left and right is a good practice. When all the drag events are blocking
              * you disable scrolling on that area.
              * @events  drag, drapleft, dragright, dragup, dragdown
              */
             Hammer.gestures.Drag = {
                 name: 'drag',
                 index: 50,
                 defaults: {
                     drag_min_distance: 10,
                     // set 0 for unlimited, but this can conflict with transform
                     drag_max_touches: 1,
                     // prevent default browser behavior when dragging occurs
                     // be careful with it, it makes the element a blocking element
                     // when you are using the drag gesture, it is a good practice to set this true
                     drag_block_horizontal: false,
                     drag_block_vertical: false,
                     // drag_lock_to_axis keeps the drag gesture on the axis that it started on,
                     // It disallows vertical directions if the initial direction was horizontal, and vice versa.
                     drag_lock_to_axis: false,
                     // drag lock only kicks in when distance > drag_lock_min_distance
                     // This way, locking occurs only when the distance has become large enough to reliably determine the direction
                     drag_lock_min_distance: 25
                 },
                 triggered: false,
                 handler: function dragGesture(ev, inst) {
                     // current gesture isnt drag, but dragged is true
                     // this means an other gesture is busy. now call dragend
                     if (Hammer.detection.current.name != this.name && this.triggered) {
                         inst.trigger(this.name + 'end', ev);
                         this.triggered = false;
                         return;
                     }

                     // max touches
                     if (inst.options.drag_max_touches > 0 &&
                         ev.touches.length > inst.options.drag_max_touches) {
                         return;
                     }

                     switch (ev.eventType) {
                         case Hammer.EVENT_START:
                             this.triggered = false;
                             break;

                         case Hammer.EVENT_MOVE:
                             // when the distance we moved is too small we skip this gesture
                             // or we can be already in dragging
                             if (ev.distance < inst.options.drag_min_distance &&
                                 Hammer.detection.current.name != this.name) {
                                 return;
                             }

                             // we are dragging!
                             Hammer.detection.current.name = this.name;

                             // lock drag to axis?
                             if (Hammer.detection.current.lastEvent.drag_locked_to_axis || (inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance)) {
                                 ev.drag_locked_to_axis = true;
                             }
                             var last_direction = Hammer.detection.current.lastEvent.direction;
                             if (ev.drag_locked_to_axis && last_direction !== ev.direction) {
                                 // keep direction on the axis that the drag gesture started on
                                 if (Hammer.utils.isVertical(last_direction)) {
                                     ev.direction = (ev.deltaY < 0) ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;
                                 }
                                 else {
                                     ev.direction = (ev.deltaX < 0) ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;
                                 }
                             }

                             // first time, trigger dragstart event
                             if (!this.triggered) {
                                 inst.trigger(this.name + 'start', ev);
                                 this.triggered = true;
                             }

                             // trigger normal event
                             inst.trigger(this.name, ev);

                             // direction event, like dragdown
                             inst.trigger(this.name + ev.direction, ev);

                             // block the browser events
                             if ((inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction)) ||
                                 (inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction))) {
                                 ev.preventDefault();
                             }
                             break;

                         case Hammer.EVENT_END:
                             // trigger dragend
                             if (this.triggered) {
                                 inst.trigger(this.name + 'end', ev);
                             }

                             this.triggered = false;
                             break;
                     }
                 }
             };


             /**
              * Transform
              * User want to scale or rotate with 2 fingers
              * @events  transform, pinch, pinchin, pinchout, rotate
              */
             Hammer.gestures.Transform = {
                 name: 'transform',
                 index: 45,
                 defaults: {
                     // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1
                     transform_min_scale: 0.01,
                     // rotation in degrees
                     transform_min_rotation: 1,
                     // prevent default browser behavior when two touches are on the screen
                     // but it makes the element a blocking element
                     // when you are using the transform gesture, it is a good practice to set this true
                     transform_always_block: false
                 },
                 triggered: false,
                 handler: function transformGesture(ev, inst) {
                     // current gesture isnt drag, but dragged is true
                     // this means an other gesture is busy. now call dragend
                     if (Hammer.detection.current.name != this.name && this.triggered) {
                         inst.trigger(this.name + 'end', ev);
                         this.triggered = false;
                         return;
                     }

                     // atleast multitouch
                     if (ev.touches.length < 2) {
                         return;
                     }

                     // prevent default when two fingers are on the screen
                     if (inst.options.transform_always_block) {
                         ev.preventDefault();
                     }

                     switch (ev.eventType) {
                         case Hammer.EVENT_START:
                             this.triggered = false;
                             break;

                         case Hammer.EVENT_MOVE:
                             var scale_threshold = Math.abs(1 - ev.scale);
                             var rotation_threshold = Math.abs(ev.rotation);

                             // when the distance we moved is too small we skip this gesture
                             // or we can be already in dragging
                             if (scale_threshold < inst.options.transform_min_scale &&
                                 rotation_threshold < inst.options.transform_min_rotation) {
                                 return;
                             }

                             // we are transforming!
                             Hammer.detection.current.name = this.name;

                             // first time, trigger dragstart event
                             if (!this.triggered) {
                                 inst.trigger(this.name + 'start', ev);
                                 this.triggered = true;
                             }

                             inst.trigger(this.name, ev); // basic transform event

                             // trigger rotate event
                             if (rotation_threshold > inst.options.transform_min_rotation) {
                                 inst.trigger('rotate', ev);
                             }

                             // trigger pinch event
                             if (scale_threshold > inst.options.transform_min_scale) {
                                 inst.trigger('pinch', ev);
                                 inst.trigger('pinch' + ((ev.scale < 1) ? 'in' : 'out'), ev);
                             }
                             break;

                         case Hammer.EVENT_END:
                             // trigger dragend
                             if (this.triggered) {
                                 inst.trigger(this.name + 'end', ev);
                             }

                             this.triggered = false;
                             break;
                     }
                 }
             };


             /**
              * Touch
              * Called as first, tells the user has touched the screen
              * @events  touch
              */
             Hammer.gestures.Touch = {
                 name: 'touch',
                 index: -Infinity,
                 defaults: {
                     // call preventDefault at touchstart, and makes the element blocking by
                     // disabling the scrolling of the page, but it improves gestures like
                     // transforming and dragging.
                     // be careful with using this, it can be very annoying for users to be stuck
                     // on the page
                     prevent_default: false,

                     // disable mouse events, so only touch (or pen!) input triggers events
                     prevent_mouseevents: false
                 },
                 handler: function touchGesture(ev, inst) {
                     if (inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {
                         ev.stopDetect();
                         return;
                     }

                     if (inst.options.prevent_default) {
                         ev.preventDefault();
                     }

                     if (ev.eventType == Hammer.EVENT_START) {
                         inst.trigger(this.name, ev);
                     }
                 }
             };


             /**
              * Release
              * Called as last, tells the user has released the screen
              * @events  release
              */
             Hammer.gestures.Release = {
                 name: 'release',
                 index: Infinity,
                 handler: function releaseGesture(ev, inst) {
                     if (ev.eventType == Hammer.EVENT_END) {
                         inst.trigger(this.name, ev);
                     }
                 }
             };

             // node export
             if (typeof module === 'object' && typeof module.exports === 'object') {
                 module.exports = Hammer;
             }
                 // just window export
             else {
                 window.Hammer = Hammer;

                 // requireJS module definition
                 if (typeof window.define === 'function' && window.define.amd) {
                     window.define('hammer', [], function () {
                         return Hammer;
                     });
                 }
             }
         })(JSC3D);
     </script>

     <!--script type="text/javascript" src="js/jsc3d.webgl.js"></script-->
     <script type="text/javascript">
         /**
 * @preserve Copyright (c) 2011~2014 
 * Humu <humu2009@gmail.com>, Laurent Piroelle <laurent.piroelle@fabzat.com>. 
 * This file is part of jsc3d project, which is freely distributable under the 
 * terms of the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */


         /**
          * @namespace JSC3D
          */
         var JSC3D = JSC3D || {};


         /**
          * Issue List:
          * 1. Does not support data updating.
          * 2. Picking does not work correctly on old Firefox (tested on FF6, 8). This may be related to some defect in FF's frame-buffer binding.
          * 3. Each 1st frame is not presented properly when switching from 'standard' to other definitions on old Firefox. There will be a blank frame then.
          */

         /**
          * @class WebGLRenderBackend
          *
          * This class implements an optional WebGL render back-end for {JSC3D.Viewer}. If enabled, it takes 
          * place of {JSC3D.Viewer}'s default software rendering module and provides high performance rendering.
          */
         JSC3D.WebGLRenderBackend = function (canvas, releaseLocalBuffers) {
             this.canvas = canvas;
             // IE11 only has a partial implementation of WebGL API, thus some special treatments are required 
             // to avoid usage of unsupported methods and properties.
             this.isIE11 = (JSC3D.PlatformInfo.browser == 'ie') && (parseInt(JSC3D.PlatformInfo.version) >= 11);
             this.gl = canvas.getContext('experimental-webgl', {/*antialias: false,*/ preserveDrawingBuffer: true/*this is necessary since we need to read back pixels for picking*/ }) || canvas.getContext('webgl');
             if (!this.gl)
                 throw 'JSC3D.WebGLRenderBackend constructor failed: Cannot get WebGL context!';
             this.definition = 'standard';
             this.bkgColors = [0, 0];
             this.bkgTexture = null;
             this.backFB = null;
             this.pickingFB = null;
             this.pickingResult = new Uint8Array(4);
             this.releaseLocalBuffers = releaseLocalBuffers || false;

             this.screen_vs = '#ifdef GL_ES \n' +
                                 '	precision mediump float; \n' +
                                 '#endif	\n' +
                                 '\n' +
                                 'attribute vec2 a_position; \n' +
                                 'varying vec2 v_texCoord; \n' +
                                 '\n' +
                                 'void main(void) { \n' +
                                 '	v_texCoord = vec2(0.5, 0.5) * a_position + vec2(0.5, 0.5); \n' +
                                 '	gl_Position = vec4(a_position, 1.0, 1.0); \n' +
                                 '}';
             this.screen_fs = '#ifdef GL_ES \n' +
                                 '	precision mediump float; \n' +
                                 '#endif	\n' +
                                 '\n' +
                                 'uniform sampler2D s_screenTexture; \n' +
                                 'varying vec2 v_texCoord; \n' +
                                 '\n' +
                                 'void main(void) { \n' +
                                 '	gl_FragColor = texture2D(s_screenTexture, v_texCoord); \n' +
                                 '}';
             this.gradient_background_vs = '#ifdef GL_ES \n' +
                                             '	precision mediump float; \n' +
                                             '#endif	\n' +
                                             '\n' +
                                             'uniform vec3 u_color1; \n' +
                                             'uniform vec3 u_color2; \n' +
                                             'attribute vec2 a_position; \n' +
                                             'varying vec4 v_color; \n' +
                                             '\n' +
                                             'void main(void) { \n' +
                                             '	v_color = vec4(a_position.y > 0.0 ? u_color1 : u_color2, 1.0); \n' +
                                             '	gl_Position = vec4(a_position, 1.0, 1.0); \n' +
                                             '}';
             this.gradient_background_fs = '#ifdef GL_ES \n' +
                                             '	precision mediump float; \n' +
                                             '#endif	\n' +
                                             '\n' +
                                             'varying vec4 v_color; \n' +
                                             '\n' +
                                             'void main(void) { \n' +
                                             '	gl_FragColor = v_color;' +
                                             '}';
             this.frame_vs = '#ifdef GL_ES \n' +
                             '	precision mediump float; \n' +
                             '#endif	\n' +
                             '\n' +
                             'uniform bool u_isPoint; \n' +
                             'uniform mat4 u_transformMatrix; \n' +
                             'attribute vec3 a_position; \n' +
                             '\n' +
                             'void main(void) { \n' +
                             '	if(u_isPoint) { \n' +
                             '		gl_PointSize = 2.0; \n' +
                             '	} \n' +
                             '	gl_Position = u_transformMatrix * vec4(a_position, 1.0); \n' +
                             '}';
             this.frame_fs = '#ifdef GL_ES \n' +
                             '	precision mediump float; \n' +
                             '#endif	\n' +
                             '\n' +
                             'uniform vec3 u_materialColor; \n' +
                             '\n' +
                             'void main(void) { \n' +
                             '	gl_FragColor = vec4(u_materialColor, 1.0); \n' +
                             '}';
             this.solid_vs = '#ifdef GL_ES \n' +
                             '	precision mediump float; \n' +
                             '#endif	\n' +
                             '\n' +
                             'uniform bool u_isLit; \n' +
                             'uniform bool u_isCast; \n' +
                             'uniform bool u_hasTexture; \n' +
                             'uniform mat3 u_rotationMatrix; \n' +
                             'uniform mat4 u_transformMatrix; \n' +
                             'attribute vec3 a_position; \n' +
                             'attribute vec3 a_normal; \n' +
                             'attribute vec2 a_texCoord; \n' +
                             'varying vec3 v_normal; \n' +
                             'varying vec2 v_texCoord; \n' +
                             '\n' +
                             'void main(void) { \n' +
                             '	if(u_isLit) { \n' +
                             '		v_normal = u_rotationMatrix * a_normal; \n' +
                             '	} \n' +
                             '	if(u_hasTexture) { \n' +
                             '		v_texCoord = a_texCoord; \n' +
                             '	} \n' +
                             '	gl_Position = u_transformMatrix * vec4(a_position, 1.0); \n' +
                             '}';
             this.solid_fs = '#ifdef GL_ES \n' +
                             '	precision mediump float; \n' +
                             '#endif	\n' +
                             '\n' +
                             'uniform bool  u_isLit; \n' +
                             'uniform bool  u_isCast; \n' +
                             'uniform bool  u_hasTexture; \n' +
                             'uniform float u_opacity; \n' +
                             'uniform sampler2D s_palette; \n' +
                             'uniform sampler2D s_texture; \n' +
                             'uniform sampler2D s_sphereTexture; \n' +
                             'varying vec3 v_normal; \n' +
                             'varying vec2 v_texCoord; \n' +
                             '\n' +
                             'void main(void) { \n' +
                             '	vec4 materialColor = u_isLit ? vec4(texture2D(s_palette, vec2(abs(v_normal.z), 0.0)).rgb, u_opacity) : vec4(1.0, 1.0, 1.0, u_opacity); \n' +
                             '	if(u_isCast) { \n' +
                             '		gl_FragColor = materialColor * texture2D(s_sphereTexture, vec2(0.5, -0.5) * v_normal.xy + vec2(0.5, 0.5)); \n' +
                             '	} \n' +
                             '	else { \n' +
                             '		gl_FragColor = u_hasTexture ? (materialColor * texture2D(s_texture, v_texCoord)) : materialColor; \n' +
                             '	} \n' +
                             '}';
             this.picking_vs = '#ifdef GL_ES \n' +
                                 '	precision mediump float; \n' +
                                 '#endif	\n' +
                                 '\n' +
                                 'uniform mat4 u_transformMatrix; \n' +
                                 'attribute vec3 a_position; \n' +
                                 '\n' +
                                 'void main(void) { \n' +
                                 '	gl_Position = u_transformMatrix * vec4(a_position, 1.0); \n' +
                                 '}';
             this.picking_fs = '#ifdef GL_ES \n' +
                                 '	precision mediump float; \n' +
                                 '#endif	\n' +
                                 '\n' +
                                 'uniform vec3 u_pickingId; \n' +
                                 '\n' +
                                 'void main(void) { \n' +
                                 '	gl_FragColor = vec4(u_pickingId, 1.0); \n' +
                                 '}';

             function createProgram(gl, vSrc, fSrc) {
                 var vShader = gl.createShader(gl.VERTEX_SHADER);
                 gl.shaderSource(vShader, vSrc);
                 gl.compileShader(vShader);
                 if (!gl.getShaderParameter(vShader, gl.COMPILE_STATUS)) {
                     if (JSC3D.console)
                         JSC3D.console.logWarning('Error occured in shader compilation: ' + gl.getShaderInfoLog(vShader) + ' The corresponding program will be ignored.');
                     return null;
                 }

                 var fShader = gl.createShader(gl.FRAGMENT_SHADER);
                 gl.shaderSource(fShader, fSrc);
                 gl.compileShader(fShader);
                 if (!gl.getShaderParameter(fShader, gl.COMPILE_STATUS)) {
                     if (JSC3D.console)
                         JSC3D.console.logWarning('Error occured in shader compilation: ' + gl.getShaderInfoLog(fShader) + ' The corresponding program will be ignored.');
                     return null;
                 }

                 var program = gl.createProgram();
                 gl.attachShader(program, vShader);
                 gl.attachShader(program, fShader);
                 gl.linkProgram(program);
                 if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                     if (JSC3D.console)
                         JSC3D.console.logWarning('Error occured when generating program: ' + gl.getProgramInfoLog(program) + ' This program will be ignored.');
                     return null;
                 }

                 program.attributes = {};
                 var numOfAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
                 for (var i = 0; i < numOfAttribs; i++) {
                     var attrib = gl.getActiveAttrib(program, i);
                     program.attributes[attrib.name] = gl.getAttribLocation(program, attrib.name);
                 }

                 program.uniforms = {};
                 var numOfUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                 for (var i = 0; i < numOfUniforms; i++) {
                     var uniform = gl.getActiveUniform(program, i);
                     program.uniforms[uniform.name] = gl.getUniformLocation(program, uniform.name);
                 }

                 return program;
             }

             this.programs = {
                 screen: createProgram(this.gl, this.screen_vs, this.screen_fs),
                 gradient_background: createProgram(this.gl, this.gradient_background_vs, this.gradient_background_fs),
                 frame: createProgram(this.gl, this.frame_vs, this.frame_fs),
                 solid: createProgram(this.gl, this.solid_vs, this.solid_fs),
                 picking: createProgram(this.gl, this.picking_vs, this.picking_fs)
             };

             this.canvasBoard = this.gl.createBuffer();
             this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.canvasBoard);
             this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]), this.gl.STATIC_DRAW);
             this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
         };

         /**
          * Set colors that will be applied to fill the background.
          */
         JSC3D.WebGLRenderBackend.prototype.setBackgroundColors = function (color1, color2) {
             this.bkgColors = [new Float32Array([(color1 & 0xff0000) / 16777216, (color1 & 0xff00) / 65536, (color1 & 0xff) / 256])];
             if (color1 != color2)
                 this.bkgColors.push(new Float32Array([(color2 & 0xff0000) / 16777216, (color2 & 0xff00) / 65536, (color2 & 0xff) / 256]));
         };

         /**
          * Set an image to be used as background.
          */
         JSC3D.WebGLRenderBackend.prototype.setBackgroundImage = function (img) {
             var gl = this.gl;

             this.bkgTexture = gl.createTexture();
             gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
             gl.bindTexture(gl.TEXTURE_2D, this.bkgTexture);
             gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
             gl.bindTexture(gl.TEXTURE_2D, null);
             gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
         };

         /**
          * Begin to render a new frame.
          */
         JSC3D.WebGLRenderBackend.prototype.beginFrame = function (definition, hasBackground) {
             var gl = this.gl;

             function prepareFB(gl, fbo, w, h) {
                 gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);

                 // create a render buffer object and set it as the depth attachment of the fbo
                 var depthAttachment = gl.createRenderbuffer();
                 gl.bindRenderbuffer(gl.RENDERBUFFER, depthAttachment);
                 gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w, h);
                 gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthAttachment);
                 gl.bindRenderbuffer(gl.RENDERBUFFER, null);

                 // create a texture object and set it as the color attachment of the fbo
                 var colorAttachment = gl.createTexture();
                 //gl.activeTexture(gl.TEXTURE0);
                 gl.bindTexture(gl.TEXTURE_2D, colorAttachment);
                 gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorAttachment, 0);
                 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                 gl.bindTexture(gl.TEXTURE_2D, null);

                 fbo.width = w;
                 fbo.height = h;
                 fbo.texture = colorAttachment;
                 fbo.depthRB = depthAttachment;
             }

             function destroyFB(gl, fbo) {
                 gl.deleteRenderbuffer(fbo.depthRB);
                 gl.deleteTexture(fbo.texture);
                 gl.deleteFramebuffer(fbo);
             }

             // create the picking frame-buffer
             if (!this.pickingFB) {
                 this.pickingFB = gl.createFramebuffer();
                 prepareFB(gl, this.pickingFB, this.canvas.width, this.canvas.height);
                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);
             }

             var frameWidth = this.canvas.width;
             var frameHeight = this.canvas.height;
             switch (definition) {
                 case 'low':
                     frameWidth = frameWidth >> 1;
                     frameHeight = frameHeight >> 1;
                     break;
                 case 'high':
                     frameWidth *= 2;
                     frameHeight *= 2;
                     break;
                 case 'standard':
                 default:
                     break;
             }

             /*
              * For definitions other than 'standard', drawings will be generated in the back frame-buffer
              * and then resampled to be applied on canvas.
              */
             if (frameWidth != this.canvas.width) {
                 if (!this.backFB) {
                     // create the back frame-buffer and bind it as render target
                     this.backFB = gl.createFramebuffer();
                     prepareFB(gl, this.backFB, frameWidth, frameHeight);
                 }
                 else if (this.definition != definition) {
                     // reallocate storage for the back frame-buffer as definition has changed, then bind it
                     // as render target
                     prepareFB(gl, this.backFB, frameWidth, frameHeight);
                 }
                 else {
                     // bind the back frame-buffer as render target
                     gl.bindFramebuffer(gl.FRAMEBUFFER, this.backFB);
                 }
             }
             else if (this.backFB) {
                 // delete and destroy the back frame-buffer as it is no longer needed under 'standard' definition
                 destroyFB(gl, this.backFB);
                 this.backFB = null;
             }

             this.definition = definition;

             gl.viewport(0, 0, frameWidth, frameHeight);

             /*
              * Clear canvas with the given background.
              */
             if (!hasBackground) {
                 /*
                  * Background should be transparent.
                  */
                 gl.clearColor(0, 0, 0, 0);
                 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
             }
             else if (this.bkgTexture) {
                 /*
                  * Apply background texture.
                  */
                 gl.frontFace(gl.CCW);
                 gl.disable(gl.DEPTH_TEST);
                 gl.clear(gl.DEPTH_BUFFER_BIT);
                 gl.useProgram(this.programs.screen);
                 gl.activeTexture(gl.TEXTURE0);
                 gl.bindTexture(gl.TEXTURE_2D, this.bkgTexture);
                 gl.uniform1i(this.programs.screen.uniforms['s_screenTexture'], 0);
                 gl.enableVertexAttribArray(0);
                 gl.bindBuffer(gl.ARRAY_BUFFER, this.canvasBoard);
                 gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                 gl.drawArrays(gl.TRIANGLES, 0, 6);
                 gl.bindBuffer(gl.ARRAY_BUFFER, null);
                 gl.bindTexture(gl.TEXTURE_2D, null);
             }
             else if (this.bkgColors.length > 1) {
                 /*
                  * Draw gradient background.
                  */
                 gl.frontFace(gl.CCW);
                 gl.disable(gl.DEPTH_TEST);
                 gl.clear(gl.DEPTH_BUFFER_BIT);
                 gl.useProgram(this.programs.gradient_background);
                 gl.uniform3fv(this.programs.gradient_background.uniforms['u_color1'], this.bkgColors[0]);
                 gl.uniform3fv(this.programs.gradient_background.uniforms['u_color2'], this.bkgColors[1]);
                 gl.enableVertexAttribArray(0);
                 gl.bindBuffer(gl.ARRAY_BUFFER, this.canvasBoard);
                 gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                 gl.drawArrays(gl.TRIANGLES, 0, 6);
                 gl.bindBuffer(gl.ARRAY_BUFFER, null);
             }
             else {
                 /*
                  * Clear canvas with a single background color.
                  */
                 var color = this.bkgColors[0];
                 gl.clearColor(color[0], color[1], color[2], 1);
                 gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
             }
         };

         /**
          * End rendering of a frame.
          */
         JSC3D.WebGLRenderBackend.prototype.endFrame = function () {
             var gl = this.gl;

             // unbind any additional frame-buffer and redirect latter output to canvas
             gl.bindFramebuffer(gl.FRAMEBUFFER, null);

             switch (this.definition) {
                 case 'low':
                 case 'high':
                     if (this.backFB) {
                         // resample the drawings in the back frame-buffer and apply it to canvas
                         gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                         gl.frontFace(gl.CCW);
                         gl.disable(gl.DEPTH_TEST);
                         gl.useProgram(this.programs.screen);
                         gl.activeTexture(gl.TEXTURE0);
                         gl.bindTexture(gl.TEXTURE_2D, this.backFB.texture);
                         gl.uniform1i(this.programs.screen.uniforms['s_screenTexture'], 0);
                         gl.enableVertexAttribArray(0);
                         gl.bindBuffer(gl.ARRAY_BUFFER, this.canvasBoard);
                         gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.TRIANGLES, 0, 6);
                         gl.bindBuffer(gl.ARRAY_BUFFER, null);
                         gl.bindTexture(gl.TEXTURE_2D, null);
                     }
                     break;
                 case 'standard':
                 default:
                     break;
             }

             gl.flush();
         };

         /**
          * Do render a new frame.
          */
         JSC3D.WebGLRenderBackend.prototype.render = function (renderList, transformMatrix, normalMatrix, renderMode, defaultMaterial, sphereMap, isCullingDisabled) {
             var gl = this.gl;

             var transformMat4Flattened = new Float32Array([
                 transformMatrix.m00, transformMatrix.m10, transformMatrix.m20, 0,
                 transformMatrix.m01, transformMatrix.m11, transformMatrix.m21, 0,
                 transformMatrix.m02, transformMatrix.m12, transformMatrix.m22, 0,
                 transformMatrix.m03, transformMatrix.m13, transformMatrix.m23, 1
             ]);

             var normalMat3Flattened = new Float32Array([
                 normalMatrix.m00, normalMatrix.m10, normalMatrix.m20,
                 normalMatrix.m01, normalMatrix.m11, normalMatrix.m21,
                 normalMatrix.m02, normalMatrix.m12, normalMatrix.m22
             ]);

             function sortRenderList(rlist) {
                 var opaque = [], transparent = [];

                 // sort the input meshes into an opaque list and a transparent list
                 for (var i = 0; i < rlist.length; i++) {
                     var mesh = rlist[i];
                     // is it transparent?
                     if ((mesh.material || defaultMaterial).transparency > 0 || mesh.hasTexture() && mesh.texture.hasTransparency) {
                         // calculate depth of this mesh
                         if (mesh.c)
                             mesh.aabb.center(mesh.c);
                         else
                             mesh.c = mesh.aabb.center();
                         JSC3D.Math3D.transformVectors(transformMatrix, mesh.c, mesh.c);
                         // add it to the transparent list
                         transparent.push(mesh);
                     }
                     else
                         opaque.push(mesh);
                 }

                 // sort the transparent meshes from the farthest closer
                 transparent.sort(function (m0, m1) {
                     return m0.c[2] - m1.c[2];
                 });

                 // return a new render list that is in correct order
                 return transparent.length > 0 ? opaque.concat(transparent) : opaque;
             }

             // sort render list
             renderList = sortRenderList(renderList);

             // render the color pass
             this.renderColorPass(renderList, transformMat4Flattened, normalMat3Flattened, renderMode, defaultMaterial, sphereMap, isCullingDisabled);

             // render the picking pass
             if (this.pickingFB) {
                 gl.bindFramebuffer(gl.FRAMEBUFFER, this.pickingFB);
                 this.renderPickingPass(renderList, transformMat4Flattened, defaultMaterial, isCullingDisabled);
                 gl.bindFramebuffer(gl.FRAMEBUFFER, null);
             }
         };

         /**
          * Pick at a given position.
          */
         JSC3D.WebGLRenderBackend.prototype.pick = function (x, y) {
             if (!this.pickingFB)
                 return 0;

             var gl = this.gl;

             // read back a point at the given position from the picking buffer
             gl.bindFramebuffer(gl.FRAMEBUFFER, this.pickingFB);
             gl.readPixels(x, this.pickingFB.height - y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, this.pickingResult);
             gl.bindFramebuffer(gl.FRAMEBUFFER, null);

             // return the picked mesh id at the position, or 0 if none
             return this.pickingResult[0] << 16 | this.pickingResult[1] << 8 | this.pickingResult[2];
         };

         /**
          * Render a given list of meshes, generating colored stuff of this frame.
          * @private
          */
         JSC3D.WebGLRenderBackend.prototype.renderColorPass = function (renderList, transformMat4, normalMat3, renderMode, defaultMaterial, sphereMap, isCullingDisabled) {
             if (sphereMap && sphereMap.hasData() && !sphereMap.compiled)
                 this.compileTexture(sphereMap);

             var gl = this.gl;

             gl.disable(gl.BLEND);
             gl.enable(gl.DEPTH_TEST);
             gl.depthMask(true);
             gl.frontFace(gl.CCW);

             var curProgram = null;
             var isBlendEnabled = false;

             for (var i = 0; i < renderList.length; i++) {
                 var mesh = renderList[i];
                 if (mesh.isTrivial() || !mesh.visible)
                     continue;

                 var material = mesh.material || defaultMaterial;
                 var texture = mesh.hasTexture() ? mesh.texture : null;
                 var isTransparent = (material.transparency > 0) || (texture && texture.hasTransparency);
                 var opacity = 1 - material.transparency;

                 if (!material.compiled)
                     this.compileMaterial(material);
                 if (texture && !texture.compiled)
                     this.compileTexture(texture);

                 if (isCullingDisabled || mesh.isDoubleSided)
                     gl.disable(gl.CULL_FACE);
                 else
                     gl.enable(gl.CULL_FACE);

                 // switch blend mode
                 if (isTransparent != isBlendEnabled) {
                     if (isTransparent) {
                         gl.depthMask(false);
                         gl.enable(gl.BLEND);
                         gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE);
                     }
                     else {
                         gl.depthMask(true);
                         gl.disable(gl.BLEND);
                     }
                     isBlendEnabled = isTransparent;
                 }

                 var isSphereMapped = mesh.isEnvironmentCast && (sphereMap != null);

                 // resolve current render mode and then choose a right program
                 var rmode = mesh.renderMode || renderMode;
                 var program;
                 switch (rmode) {
                     case 'point':
                     case 'wireframe':
                         program = this.programs.frame;
                         break;
                     case 'flat':
                     case 'smooth':
                         program = this.programs.solid;
                         break;
                     case 'texture':
                     case 'textureflat':
                         if (!texture)
                             rmode = 'flat';
                         program = this.programs.solid;
                         break;
                     case 'texturesmooth':
                         if (!texture && !isSphereMapped)
                             rmode = 'smooth';
                         program = this.programs.solid;
                         break;
                     default:
                         rmode = 'flat';
                         program = this.programs.solid;
                         break;
                 }

                 // need to recompile the mesh?
                 if (!mesh.compiled || mesh.compiled.remderMode != rmode)
                     this.compileMesh(mesh, rmode);

                 if (curProgram != program) {
                     gl.useProgram(program);
                     curProgram = program;
                 }

                 // draw the mesh with the chosen render mode
                 switch (rmode) {
                     case 'point':
                         gl.uniform1i(program.uniforms['u_isPoint'], true);
                         gl.uniform3fv(program.uniforms['u_materialColor'], material.compiled.diffColor);
                         gl.uniformMatrix4fv(program.uniforms['u_transformMatrix'], false, transformMat4);
                         gl.enableVertexAttribArray(program.attributes['a_position']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(program.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.POINTS, 0, mesh.compiled.coordCount);
                         break;
                     case 'wireframe':
                         gl.uniform1i(program.uniforms['u_isPoint'], false);
                         gl.uniform3fv(program.uniforms['u_materialColor'], material.compiled.diffColor);
                         gl.uniformMatrix4fv(program.uniforms['u_transformMatrix'], false, transformMat4);
                         gl.enableVertexAttribArray(program.attributes['a_position']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.edges);
                         gl.vertexAttribPointer(program.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.LINES, 0, mesh.compiled.edgeCount);
                         break;
                     case 'flat':
                     case 'smooth':
                         gl.uniform1i(program.uniforms['u_isLit'], true);
                         gl.uniform1i(program.uniforms['u_isCast'], false);
                         gl.uniform1i(program.uniforms['u_hasTexture'], false);
                         gl.uniform1f(program.uniforms['u_opacity'], opacity);
                         gl.uniformMatrix3fv(program.uniforms['u_rotationMatrix'], false, normalMat3);
                         gl.uniformMatrix4fv(program.uniforms['u_transformMatrix'], false, transformMat4);
                         gl.activeTexture(gl.TEXTURE0);
                         gl.bindTexture(gl.TEXTURE_2D, material.compiled.palette);
                         gl.uniform1i(program.uniforms['s_palette'], 0);
                         gl.enableVertexAttribArray(program.attributes['a_position']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(program.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.enableVertexAttribArray(program.attributes['a_normal']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.normals);
                         gl.vertexAttribPointer(program.attributes['a_normal'], 3, gl.FLOAT, false, 0, 0);
                         gl.disableVertexAttribArray(program.attributes['a_texCoord']);
                         gl.drawArrays(gl.TRIANGLES, 0, mesh.compiled.coordCount);
                         break;
                     case 'texture':
                         gl.uniform1i(program.uniforms['u_isLit'], false);
                         gl.uniform1i(program.uniforms['u_isCast'], false);
                         gl.uniform1i(program.uniforms['u_hasTexture'], true);
                         gl.uniform1f(program.uniforms['u_opacity'], opacity);
                         gl.uniformMatrix3fv(program.uniforms['u_rotationMatrix'], false, normalMat3);
                         gl.uniformMatrix4fv(program.uniforms['u_transformMatrix'], false, transformMat4);
                         gl.activeTexture(gl.TEXTURE1);
                         gl.bindTexture(gl.TEXTURE_2D, texture.compiled.tex);
                         gl.uniform1i(program.uniforms['s_texture'], 1);
                         gl.enableVertexAttribArray(program.attributes['a_position']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(program.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.disableVertexAttribArray(program.attributes['a_normal']);
                         gl.enableVertexAttribArray(program.attributes['a_texCoord']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.texcoords);
                         gl.vertexAttribPointer(program.attributes['a_texCoord'], 2, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.TRIANGLES, 0, mesh.compiled.coordCount);
                         break;
                     case 'textureflat':
                         gl.uniform1i(program.uniforms['u_isLit'], true);
                         gl.uniform1i(program.uniforms['u_isCast'], false);
                         gl.uniform1i(program.uniforms['u_hasTexture'], true);
                         gl.uniform1f(program.uniforms['u_opacity'], opacity);
                         gl.uniformMatrix3fv(program.uniforms['u_rotationMatrix'], false, normalMat3);
                         gl.uniformMatrix4fv(program.uniforms['u_transformMatrix'], false, transformMat4);
                         gl.activeTexture(gl.TEXTURE0);
                         gl.bindTexture(gl.TEXTURE_2D, material.compiled.palette);
                         gl.uniform1i(program.uniforms['s_palette'], 0);
                         gl.activeTexture(gl.TEXTURE1);
                         gl.bindTexture(gl.TEXTURE_2D, texture.compiled.tex);
                         gl.uniform1i(program.uniforms['s_texture'], 1);
                         gl.enableVertexAttribArray(program.attributes['a_position']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(program.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.enableVertexAttribArray(program.attributes['a_normal']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.normals);
                         gl.vertexAttribPointer(program.attributes['a_normal'], 3, gl.FLOAT, false, 0, 0);
                         gl.enableVertexAttribArray(program.attributes['a_texCoord']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.texcoords);
                         gl.vertexAttribPointer(program.attributes['a_texCoord'], 2, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.TRIANGLES, 0, mesh.compiled.coordCount);
                         break;
                     case 'texturesmooth':
                         gl.uniform1i(program.uniforms['u_isLit'], true);
                         gl.uniform1i(program.uniforms['u_isCast'], isSphereMapped);
                         gl.uniform1i(program.uniforms['u_hasTexture'], !isSphereMapped);
                         gl.uniform1f(program.uniforms['u_opacity'], opacity);
                         gl.uniformMatrix3fv(program.uniforms['u_rotationMatrix'], false, normalMat3);
                         gl.uniformMatrix4fv(program.uniforms['u_transformMatrix'], false, transformMat4);
                         gl.activeTexture(gl.TEXTURE0);
                         gl.bindTexture(gl.TEXTURE_2D, material.compiled.palette);
                         gl.uniform1i(program.uniforms['s_palette'], 0);
                         if (!isSphereMapped) {
                             gl.activeTexture(gl.TEXTURE1);
                             gl.bindTexture(gl.TEXTURE_2D, texture.compiled.tex);
                             gl.uniform1i(program.uniforms['s_texture'], 1);
                         }
                         else {
                             gl.activeTexture(gl.TEXTURE2);
                             gl.bindTexture(gl.TEXTURE_2D, sphereMap.compiled.tex);
                             gl.uniform1i(program.uniforms['s_sphereTexture'], 2);
                         }
                         gl.enableVertexAttribArray(program.attributes['a_position']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(program.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.enableVertexAttribArray(program.attributes['a_normal']);
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.normals);
                         gl.vertexAttribPointer(program.attributes['a_normal'], 3, gl.FLOAT, false, 0, 0);
                         if (!isSphereMapped) {
                             gl.enableVertexAttribArray(program.attributes['a_texCoord']);
                             gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.texcoords);
                             gl.vertexAttribPointer(program.attributes['a_texCoord'], 2, gl.FLOAT, false, 0, 0);
                         }
                         else
                             gl.disableVertexAttribArray(program.attributes['a_texCoord']);
                         gl.drawArrays(gl.TRIANGLES, 0, mesh.compiled.coordCount);
                         break;
                     default:
                         break;
                 }
             }
         };

         /**
          * Fill the picking buffer of this frame.
          * @private
          */
         JSC3D.WebGLRenderBackend.prototype.renderPickingPass = function (renderList, transformMat4, defaultMaterial, isCullingDisabled) {
             var gl = this.gl;

             gl.disable(gl.BLEND);
             gl.enable(gl.DEPTH_TEST);
             gl.depthMask(true);
             gl.frontFace(gl.CCW);

             gl.viewport(0, 0, this.pickingFB.width, this.pickingFB.height);
             gl.clearColor(0, 0, 0, 1);
             gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

             gl.useProgram(this.programs.picking);

             for (var i = 0; i < renderList.length; i++) {
                 var mesh = renderList[i];
                 if (mesh.isTrivial() || !mesh.visible)
                     continue;

                 // skip the mesh if it is nearly completely transparent
                 var material = mesh.material || defaultMaterial;
                 if (material.transparency > 0.99)
                     continue;

                 if (isCullingDisabled || mesh.isDoubleSided)
                     gl.disable(gl.CULL_FACE);
                 else
                     gl.enable(gl.CULL_FACE);

                 gl.uniformMatrix4fv(this.programs.picking.uniforms['u_transformMatrix'], false, transformMat4);
                 gl.uniform3fv(this.programs.picking.uniforms['u_pickingId'], mesh.compiled.pickingId);
                 gl.enableVertexAttribArray(this.programs.picking.attributes['a_position']);

                 switch (mesh.compiled.remderMode) {
                     case 'point':
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(this.programs.picking.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.POINTS, 0, mesh.compiled.coordCount);
                         break;
                     case 'wireframe':
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.edges);
                         gl.vertexAttribPointer(this.programs.picking.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.LINES, 0, mesh.compiled.edgeCount);
                         break;
                     case 'flat':
                     case 'smooth':
                     case 'texture':
                     case 'textureflat':
                     case 'texturesmooth':
                     default:
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                         gl.vertexAttribPointer(this.programs.picking.attributes['a_position'], 3, gl.FLOAT, false, 0, 0);
                         gl.drawArrays(gl.TRIANGLES, 0, mesh.compiled.coordCount);
                         break;
                 }
             }
         };

         /**
          * Compile a mesh according to the given render mode, generating the WebGL dependent stuff.
          * @private
          */
         JSC3D.WebGLRenderBackend.prototype.compileMesh = function (mesh, renderMode) {
             if (mesh.isTrivial())
                 return false;

             renderMode = mesh.renderMode || renderMode;

             function makeWireframe(ibuf, vbuf, numOfFaces, trianglesOnly) {
                 var edges;

                 var v0, v1, v2;
                 if (trianglesOnly) {
                     edges = new Float32Array(18 * numOfFaces);
                     for (var i = 0, e = 0; i < ibuf.length; i += 4, e += 18) {
                         v0 = 3 * ibuf[i];
                         v1 = 3 * ibuf[i + 1];
                         v2 = 3 * ibuf[i + 2];

                         // v0 <-> v1
                         edges[e] = vbuf[v0];
                         edges[e + 1] = vbuf[v0 + 1];
                         edges[e + 2] = vbuf[v0 + 2];
                         edges[e + 3] = vbuf[v1];
                         edges[e + 4] = vbuf[v1 + 1];
                         edges[e + 5] = vbuf[v1 + 2];
                         // v1 <-> v2
                         edges[e + 6] = vbuf[v1];
                         edges[e + 7] = vbuf[v1 + 1];
                         edges[e + 8] = vbuf[v1 + 2];
                         edges[e + 9] = vbuf[v2];
                         edges[e + 10] = vbuf[v2 + 1];
                         edges[e + 11] = vbuf[v2 + 2];
                         // v2 <-> v0
                         edges[e + 12] = vbuf[v2];
                         edges[e + 13] = vbuf[v2 + 1];
                         edges[e + 14] = vbuf[v2 + 2];
                         edges[e + 15] = vbuf[v0];
                         edges[e + 16] = vbuf[v0 + 1];
                         edges[e + 17] = vbuf[v0 + 2];
                     }
                 }
                 else {
                     edges = [];
                     for (var i = 0, j = 0; i < numOfFaces; i++) {
                         v0 = 3 * ibuf[j++];
                         v1 = v0;
                         while (ibuf[j] > 0) {
                             v2 = 3 * ibuf[j++];
                             edges.push(vbuf[v1], vbuf[v1 + 1], vbuf[v1 + 2], vbuf[v2], vbuf[v2 + 1], vbuf[v2 + 2]);
                             v1 = v2;
                         }
                         j++;
                         // close the polygon
                         edges.push(vbuf[v1], vbuf[v1 + 1], vbuf[v1 + 2], vbuf[v0], vbuf[v0 + 1], vbuf[v0 + 2]);
                     }
                     edges = new Float32Array(edges);
                 }

                 return edges;
             }

             var gl = this.gl;

             var needFlat = (renderMode == 'flat') || (renderMode == 'textureflat');

             var hasTrianglesOnly = mesh.indexBuffer.length == 4 * mesh.faceCount;
             var hasTextureCoords = mesh.texCoordBuffer && mesh.texCoordBuffer.length >= 2;

             var ibuf = mesh.indexBuffer;
             var vbuf = mesh.vertexBuffer;
             var tbuf = mesh.texCoordBuffer;
             var tibuf = mesh.texCoordIndexBuffer || ibuf;
             var nbuf = mesh.vertexNormalBuffer;
             var nibuf = mesh.vertexNormalIndexBuffer || ibuf;
             var fnbuf = mesh.faceNormalBuffer;
             var numOfFaces = mesh.faceCount;

             if (!mesh.compiled) {
                 /*
                  * Rebuild all primitives from scratch.
                  */

                 mesh.compiled = {
                     isIndexed: false
                 };

                 mesh.compiled.pickingId = new Float32Array([
                     (mesh.internalId & 0xff0000) / 16777216, (mesh.internalId & 0xff00) / 65536, (mesh.internalId & 0xff) / 256
                 ]);

                 var triangles, edges, coords, normals, texcoords;
                 if (hasTrianglesOnly) {
                     coords = new Float32Array(9 * numOfFaces);
                     normals = new Float32Array(9 * numOfFaces);
                     if (hasTextureCoords)
                         texcoords = new Float32Array(6 * numOfFaces);
                     var v0, v1, v2;
                     var n0, n1, n2;
                     var t0, t1, t2;
                     for (var i = 0, j = 0, k = 0, faceIndex = 0; i < ibuf.length; i += 4, j += 9, k += 6, faceIndex++) {
                         v0 = ibuf[i] * 3;
                         v1 = ibuf[i + 1] * 3;
                         v2 = ibuf[i + 2] * 3;
                         coords[j] = vbuf[v0];
                         coords[j + 1] = vbuf[v0 + 1];
                         coords[j + 2] = vbuf[v0 + 2];
                         coords[j + 3] = vbuf[v1];
                         coords[j + 4] = vbuf[v1 + 1];
                         coords[j + 5] = vbuf[v1 + 2];
                         coords[j + 6] = vbuf[v2];
                         coords[j + 7] = vbuf[v2 + 1];
                         coords[j + 8] = vbuf[v2 + 2];

                         if (needFlat) {
                             n0 = faceIndex * 3;
                             normals[j] = normals[j + 3] = normals[j + 6] = fnbuf[n0];
                             normals[j + 1] = normals[j + 4] = normals[j + 7] = fnbuf[n0 + 1];
                             normals[j + 2] = normals[j + 5] = normals[j + 8] = fnbuf[n0 + 2];

                         }
                         else {
                             n0 = nibuf[i] * 3;
                             n1 = nibuf[i + 1] * 3;
                             n2 = nibuf[i + 2] * 3;
                             normals[j] = nbuf[n0];
                             normals[j + 1] = nbuf[n0 + 1];
                             normals[j + 2] = nbuf[n0 + 2];
                             normals[j + 3] = nbuf[n1];
                             normals[j + 4] = nbuf[n1 + 1];
                             normals[j + 5] = nbuf[n1 + 2];
                             normals[j + 6] = nbuf[n2];
                             normals[j + 7] = nbuf[n2 + 1];
                             normals[j + 8] = nbuf[n2 + 2];
                         }

                         if (hasTextureCoords) {
                             t0 = tibuf[i] * 2;
                             t1 = tibuf[i + 1] * 2;
                             t2 = tibuf[i + 2] * 2;
                             texcoords[k] = tbuf[t0];
                             texcoords[k + 1] = tbuf[t0 + 1];
                             texcoords[k + 2] = tbuf[t1];
                             texcoords[k + 3] = tbuf[t1 + 1];
                             texcoords[k + 4] = tbuf[t2];
                             texcoords[k + 5] = tbuf[t2 + 1];
                         }
                     }
                 }
                 else {
                     coords = [];
                     normals = [];
                     if (hasTextureCoords)
                         texcoords = [];
                     var v0, v1, v2;
                     var n0, n1, n2;
                     var t0, t1, t2;
                     for (var i = 0, j = 0; i < numOfFaces; i++) {
                         v0 = ibuf[j] * 3;
                         v1 = ibuf[j + 1] * 3;
                         n0 = nibuf[j] * 3;
                         n1 = nibuf[j + 1] * 3;
                         if (hasTextureCoords) {
                             t0 = tibuf[j] * 2;
                             t1 = tibuf[j + 1] * 2;
                         }
                         j += 2;
                         while (ibuf[j] >= 0) {
                             v2 = ibuf[j] * 3;
                             coords.push(vbuf[v0], vbuf[v0 + 1], vbuf[v0 + 2], vbuf[v1], vbuf[v1 + 1], vbuf[v1 + 2], vbuf[v2], vbuf[v2 + 1], vbuf[v2 + 2]);
                             v1 = v2;
                             if (needFlat) {
                                 n0 = i * 3;
                                 normals.push(fnbuf[n0], fnbuf[n0 + 1], fnbuf[n0 + 2], fnbuf[n0], fnbuf[n0 + 1], fnbuf[n0 + 2], fnbuf[n0], fnbuf[n0 + 1], fnbuf[n0 + 2]);
                             }
                             else {
                                 n2 = nibuf[j] * 3;
                                 normals.push(nbuf[n0], nbuf[n0 + 1], nbuf[n0 + 2], nbuf[n1], nbuf[n1 + 1], nbuf[n1 + 2], nbuf[n2], nbuf[n2 + 1], nbuf[n2 + 2]);
                                 n1 = n2;
                             }
                             if (hasTextureCoords) {
                                 t2 = tibuf[j] * 2;
                                 texcoords.push(tbuf[t0], tbuf[t0 + 1], tbuf[t1], tbuf[t1 + 1], tbuf[t2], tbuf[t2 + 1]);
                                 t1 = t2;
                             }
                             j++;
                         }
                         j++;
                     }
                     coords = new Float32Array(coords);
                     normals = new Float32Array(normals);
                     if (hasTextureCoords)
                         texcoords = new Float32Array(texcoords);
                 }

                 mesh.compiled.coords = gl.createBuffer();
                 gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.coords);
                 gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);
                 mesh.compiled.normals = gl.createBuffer();
                 gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.normals);
                 gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
                 if (hasTextureCoords) {
                     mesh.compiled.texcoords = gl.createBuffer();
                     gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.texcoords);
                     gl.bufferData(gl.ARRAY_BUFFER, texcoords, gl.STATIC_DRAW);
                 }
                 gl.bindBuffer(gl.ARRAY_BUFFER, null);

                 mesh.compiled.faceCount = numOfFaces;
                 mesh.compiled.coordCount = coords.length / 3;
             }
             else {
                 /*
                  * Do not need to rebuild, just update normal data.
                  */

                 var isFlat = (mesh.compiled.remderMode == 'flat') || (mesh.compiled.remderMode == 'textureflat');
                 if (isFlat != needFlat) {
                     var normals;
                     if (hasTrianglesOnly) {
                         normals = new Float32Array(9 * numOfFaces);
                         var n0, n1, n2
                         for (var i = 0, j = 0, faceIndex = 0; i < ibuf.length; i += 4, j += 9, faceIndex++) {
                             if (needFlat) {
                                 n0 = faceIndex * 3;
                                 normals[j] = normals[j + 3] = normals[j + 6] = fnbuf[n0];
                                 normals[j + 1] = normals[j + 4] = normals[j + 7] = fnbuf[n0 + 1];
                                 normals[j + 2] = normals[j + 5] = normals[j + 8] = fnbuf[n0 + 2];

                             }
                             else {
                                 n0 = nibuf[i] * 3;
                                 n1 = nibuf[i + 1] * 3;
                                 n2 = nibuf[i + 2] * 3;
                                 normals[j] = nbuf[n0];
                                 normals[j + 1] = nbuf[n0 + 1];
                                 normals[j + 2] = nbuf[n0 + 2];
                                 normals[j + 3] = nbuf[n1];
                                 normals[j + 4] = nbuf[n1 + 1];
                                 normals[j + 5] = nbuf[n1 + 2];
                                 normals[j + 6] = nbuf[n2];
                                 normals[j + 7] = nbuf[n2 + 1];
                                 normals[j + 8] = nbuf[n2 + 2];
                             }
                         }
                     }
                     else {
                         normals = [];
                         var n0, n1, n2;
                         for (var i = 0, j = 0; i < numOfFaces; i++) {
                             n0 = nibuf[j++] * 3;
                             n1 = nibuf[j++] * 3;
                             while (ibuf[j] >= 0) {
                                 if (needFlat) {
                                     n0 = i * 3;
                                     normals.push(fnbuf[n0], fnbuf[n0 + 1], fnbuf[n0 + 2], fnbuf[n0], fnbuf[n0 + 1], fnbuf[n0 + 2], fnbuf[n0], fnbuf[n0 + 1], fnbuf[n0 + 2]);
                                 }
                                 else {
                                     n2 = nibuf[j] * 3;
                                     normals.push(nbuf[n0], nbuf[n0 + 1], nbuf[n0 + 2], nbuf[n1], nbuf[n1 + 1], nbuf[n1 + 2], nbuf[n2], nbuf[n2 + 1], nbuf[n2 + 2]);
                                     n1 = n2;
                                 }
                                 j++;
                             }
                             j++;
                         }
                         normals = new Float32Array(normals);
                     }

                     if (this.isIE11) {
                         // IE11 does not support bufferSubData() for buffer content update. So the normal VBO has to be reallocated for the new data.
                         gl.deleteBuffer(mesh.compiled.normals);
                         mesh.compiled.normals = gl.createBuffer();
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.normals);
                         gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
                         gl.bindBuffer(gl.ARRAY_BUFFER, null);
                     }
                     else {
                         gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.normals);
                         gl.bufferSubData(gl.ARRAY_BUFFER, 0, normals);
                         gl.bindBuffer(gl.ARRAY_BUFFER, null);
                     }
                 }
             }

             /*
              * Build wireframe if it is not built yet.
              */
             if (renderMode == 'wireframe' && !mesh.compiled.edges) {
                 var edges = makeWireframe(ibuf, vbuf, numOfFaces, hasTrianglesOnly);

                 mesh.compiled.edges = gl.createBuffer();
                 gl.bindBuffer(gl.ARRAY_BUFFER, mesh.compiled.edges);
                 gl.bufferData(gl.ARRAY_BUFFER, edges, gl.STATIC_DRAW);
                 gl.bindBuffer(gl.ARRAY_BUFFER, null);

                 mesh.compiled.edgeCount = edges.length / 3;
             }

             mesh.compiled.remderMode = renderMode;

             return true;
         };

         /**
          * Compile a material, generating the WebGL dependent stuff.
          * @private
          */
         JSC3D.WebGLRenderBackend.prototype.compileMaterial = function (material) {
             var gl = this.gl;

             material.compiled = {
                 diffColor: new Float32Array([(material.diffuseColor & 0xff0000) / 16777216, (material.diffuseColor & 0xff00) / 65536, (material.diffuseColor & 0xff) / 256])
             };

             var rgba = new Uint8Array((new Uint32Array(material.getPalette())).buffer);
             // the sequence should be converted from BGRA to RGBA by swapping each 1st and 3rd components
             //TODO: this only works on Little-Endian platforms. We shall also take into account the case for Big-Endian.
             for (var i = 0; i < rgba.length; i += 4) {
                 var tmp = rgba[i];
                 rgba[i] = rgba[i + 2];
                 rgba[i + 2] = tmp;
             }

             material.compiled.palette = gl.createTexture();
             gl.bindTexture(gl.TEXTURE_2D, material.compiled.palette);
             gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, rgba);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
             gl.bindTexture(gl.TEXTURE_2D, null);

             return true;
         };

         /**
          * Compile a texture into WebGL texture object.
          * @private
          */
         JSC3D.WebGLRenderBackend.prototype.compileTexture = function (texture, genMipmap) {
             if (!texture.hasData())
                 return false;

             genMipmap = genMipmap || texture.hasMipmap();

             var gl = this.gl;

             texture.compiled = {
                 width: texture.width,
                 height: texture.height,
                 hasMipmap: genMipmap
             };

             var rgba = new Uint8Array((new Uint32Array(texture.data)).buffer);
             // convert the sequence from BGRA to RGBA by swapping each 1st and 3rd components
             //TODO: also take into account the case for Big-Endian?
             for (var i = 0; i < rgba.length; i += 4) {
                 var tmp = rgba[i];
                 rgba[i] = rgba[i + 2];
                 rgba[i + 2] = tmp;
             }

             texture.compiled.tex = gl.createTexture();
             gl.bindTexture(gl.TEXTURE_2D, texture.compiled.tex);
             gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texture.width, texture.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, rgba);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, genMipmap ? gl.LINEAR_MIPMAP_NEAREST : gl.LINEAR);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
             gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
             if (genMipmap)
                 gl.generateMipmap(gl.TEXTURE_2D);
             gl.bindTexture(gl.TEXTURE_2D, null);

             return true;
         };

     </script>

	<script type="text/javascript">
	var canvas;
	var viewer;

	function init() {
	    canvas = document.getElementById('cv');

	    if (self.innerWidth) {
	        canvas.width = self.innerWidth-50;
	    };
	    if (self.innerHeight) {
	        canvas.height = self.innerHeight-50;
	    };
	    

		viewer = new JSC3D.Viewer(canvas);
		viewer.setParameter('SceneUrl', 'models/H2Ov4.obj');
		viewer.setParameter('InitRotationX', -40);//in degrees
		viewer.setParameter('InitRotationY', 0);//on each
		viewer.setParameter('InitRotationZ', 0);//axis
		viewer.setParameter('ModelColor', '#FFFFFF');//default color for stl files for example
		//viewer.setParameter('BackgroundColor1', '#ffffff');//top colour
	    //viewer.setParameter('BackgroundColor2', '#c0c0c0');//bottom colour
	    //viewer.setParameter('BackgroundImageUrl','img/dog.jpg');
		viewer.setParameter('Background', 'off');//off,on
		viewer.setParameter('RenderMode', 'smooth');//point,wireframe,flat,smooth,texture,textureflat,texturesmooth (setRenderMode() method can be used to change current render mode at runtime.)
		viewer.setParameter('Definition', 'standard');//low,standard,high (setDefinition() can be set at runtime)
	    //viewer.setParameter('MipMapping', 'on');//add on for textures
		viewer.setParameter('CreaseAngle', '0');//This parameter only works under the 'smooth' and 'texturesmooth' render modes. If it is set to 0, the rendered result is equivalent to that under the 'flat' or 'textureflat' render mode. In most cases, an angle value between 30~45 degrees produces nice output.
		//viewer.setParameter('SphereMapUrl', 'img/dog.jpg');//Set SphereMapUrl to URL of an image that will be used as the spherical reflection map for the model. Sphere mapping is an image-based simulation technique to cast environment onto surfaces of the model. In current implementation, sphere mapping is available only under the 'texturesmooth' render mode. A mesh's isEnvironmentCast property should be set to true to indicate it is involved in shpere mapping.
		viewer.setParameter('ProgressBar', 'on');//on,off
		viewer.setParameter('Renderer','webgl');//
		viewer.init();
		viewer.update();
	}
  </script>
     <p>Coolio</p>
 </BODY>
</HTML>
